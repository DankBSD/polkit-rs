// This file was generated by gir (https://github.com/gtk-rs/gir @ cea2f7c)
// from gir-files (https://github.com/gtk-rs/gir-files @ ???)
// DO NOT EDIT

use glib::object::IsA;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib_sys;
use gobject_sys;
use libc;
use polkit;
use polkit_agent_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;

glib_wrapper! {
    pub struct Session(Object<polkit_agent_sys::PolkitAgentSession, polkit_agent_sys::PolkitAgentSessionClass, SessionClass>);

    match fn {
        get_type => || polkit_agent_sys::polkit_agent_session_get_type(),
    }
}

impl Session {
    /// Creates a new authentication session.
    ///
    /// The caller should connect to the
    /// `Session::request`,
    /// `Session::show-info`,
    /// `Session::show-error` and
    /// `Session::completed`
    /// signals and then call `Session::initiate` to initiate the authentication session.
    /// ## `identity`
    /// The identity to authenticate.
    /// ## `cookie`
    /// The cookie obtained from the PolicyKit daemon
    ///
    /// # Returns
    ///
    /// A `Session`. Free with `gobject::ObjectExt::unref`.
    pub fn new<P: IsA<polkit::Identity>>(identity: &P, cookie: &str) -> Session {
        unsafe {
            from_glib_full(polkit_agent_sys::polkit_agent_session_new(identity.as_ref().to_glib_none().0, cookie.to_glib_none().0))
        }
    }

    /// Cancels an authentication session. This will make `self` emit the `Session::completed`
    /// signal.
    pub fn cancel(&self) {
        unsafe {
            polkit_agent_sys::polkit_agent_session_cancel(self.to_glib_none().0);
        }
    }

    /// Initiates the authentication session. Before calling this method,
    /// make sure to connect to the various signals. The signals will be
    /// emitted in the <link
    /// linkend="g-main-context-push-thread-default">thread-default main
    /// loop`</link>` that this method is invoked from.
    ///
    /// Use `Session::cancel` to cancel the session.
    pub fn initiate(&self) {
        unsafe {
            polkit_agent_sys::polkit_agent_session_initiate(self.to_glib_none().0);
        }
    }

    /// Function for providing response to requests received
    /// via the `Session::request` signal.
    /// ## `response`
    /// Response from the user, typically a password.
    pub fn response(&self, response: &str) {
        unsafe {
            polkit_agent_sys::polkit_agent_session_response(self.to_glib_none().0, response.to_glib_none().0);
        }
    }

    /// The cookie obtained from the PolicyKit daemon
    pub fn get_property_cookie(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.as_ptr() as *mut gobject_sys::GObject, b"cookie\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `cookie` getter")
        }
    }

    /// The identity to authenticate.
    pub fn get_property_identity(&self) -> Option<polkit::Identity> {
        unsafe {
            let mut value = Value::from_type(<polkit::Identity as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.as_ptr() as *mut gobject_sys::GObject, b"identity\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `identity` getter")
        }
    }

    /// Emitted when the authentication session has been completed or
    /// cancelled. The `gained_authorization` parameter is `true` only if
    /// the user successfully authenticated.
    ///
    /// Upon receiving this signal, the user should free `session` using `gobject::ObjectExt::unref`.
    /// ## `gained_authorization`
    /// `true` only if the authorization was successfully obtained.
    pub fn connect_completed<F: Fn(&Session, bool) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn completed_trampoline<F: Fn(&Session, bool) + 'static>(this: *mut polkit_agent_sys::PolkitAgentSession, gained_authorization: glib_sys::gboolean, f: glib_sys::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), from_glib(gained_authorization))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"completed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(completed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// Emitted when the user is requested to answer a question.
    ///
    /// When the response has been collected from the user, call `Session::response`.
    /// ## `request`
    /// The request to show the user, e.g. "name: " or "password: ".
    /// ## `echo_on`
    /// `true` if the response to the request SHOULD be echoed on the
    ///  screen, `false` if the response MUST NOT be echoed to the screen.
    pub fn connect_request<F: Fn(&Session, &str, bool) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn request_trampoline<F: Fn(&Session, &str, bool) + 'static>(this: *mut polkit_agent_sys::PolkitAgentSession, request: *mut libc::c_char, echo_on: glib_sys::gboolean, f: glib_sys::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &GString::from_glib_borrow(request), from_glib(echo_on))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"request\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(request_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// Emitted when there is information related to an error condition to be displayed to the user.
    /// ## `text`
    /// An error string to display to the user.
    pub fn connect_show_error<F: Fn(&Session, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_error_trampoline<F: Fn(&Session, &str) + 'static>(this: *mut polkit_agent_sys::PolkitAgentSession, text: *mut libc::c_char, f: glib_sys::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &GString::from_glib_borrow(text))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-error\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_error_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    /// Emitted when there is information to be displayed to the user.
    /// ## `text`
    /// A string to display to the user.
    pub fn connect_show_info<F: Fn(&Session, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_info_trampoline<F: Fn(&Session, &str) + 'static>(this: *mut polkit_agent_sys::PolkitAgentSession, text: *mut libc::c_char, f: glib_sys::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &GString::from_glib_borrow(text))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-info\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_info_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Session {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Session")
    }
}
