// Generated by gir (https://github.com/gtk-rs/gir @ 796942c)
// from /usr/local/share/gir-1.0 (@ ???)
// DO NOT EDIT

use crate::Subject;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use std::ptr;

glib::wrapper! {
    /// An object for representing a UNIX process. NOTE: This object as
    /// designed is now known broken; a mechanism to exploit a delay in
    /// start time in the Linux kernel was identified. Avoid
    /// calling `polkit_subject_equal()` to compare two processes.
    ///
    /// To uniquely identify processes, both the process id and the start
    /// time of the process (a monotonic increasing value representing the
    /// time since the kernel was started) is used.
    ///
    /// NOTE: This object stores, and provides access to, the real UID of the
    /// process. That value can change over time (with set*uid*(2) and exec*(2)).
    /// Checks whether an operation is allowed need to take care to use the UID
    /// value as of the time when the operation was made (or, following the `open()`
    /// privilege check model, when the connection making the operation possible
    /// was initiated). That is usually done by initializing this with
    /// [`new_for_owner()`][Self::new_for_owner()] with trusted data.
    ///
    /// # Implements
    ///
    /// [`trait@glib::ObjectExt`], [`SubjectExt`][trait@crate::prelude::SubjectExt]
    pub struct UnixProcess(Object<ffi::PolkitUnixProcess, ffi::PolkitUnixProcessClass>) @implements Subject;

    match fn {
        type_ => || ffi::polkit_unix_process_get_type(),
    }
}

impl UnixProcess {
    /// (deprecated)
    #[doc(alias = "polkit_unix_process_get_owner")]
    #[doc(alias = "get_owner")]
    pub fn owner(&self) -> Result<i32, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::polkit_unix_process_get_owner(self.to_glib_none().0, &mut error);
            if error.is_null() {
                Ok(ret)
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Gets the process id for `self`.
    ///
    /// # Returns
    ///
    /// The process id for `self`.
    #[doc(alias = "polkit_unix_process_get_pid")]
    #[doc(alias = "get_pid")]
    pub fn pid(&self) -> i32 {
        unsafe { ffi::polkit_unix_process_get_pid(self.to_glib_none().0) }
    }

    /// Gets the start time of `self`.
    ///
    /// # Returns
    ///
    /// The start time of `self`.
    #[doc(alias = "polkit_unix_process_get_start_time")]
    #[doc(alias = "get_start_time")]
    pub fn start_time(&self) -> u64 {
        unsafe { ffi::polkit_unix_process_get_start_time(self.to_glib_none().0) }
    }

    /// Gets the user id for `self`. Note that this is the real user-id,
    /// not the effective user-id.
    ///
    /// NOTE: The UID may change over time, so the returned value may not match the
    /// current state of the underlying process; or the UID may have been set by
    /// [`new_for_owner()`][Self::new_for_owner()] or [`set_uid()`][Self::set_uid()],
    /// in which case it may not correspond to the actual UID of the referenced
    /// process at all (at any point in time).
    ///
    /// # Returns
    ///
    /// The user id for `self` or -1 if unknown.
    #[doc(alias = "polkit_unix_process_get_uid")]
    #[doc(alias = "get_uid")]
    pub fn uid(&self) -> i32 {
        unsafe { ffi::polkit_unix_process_get_uid(self.to_glib_none().0) }
    }

    /// Sets `pid` for `self`.
    /// ## `pid`
    /// A process id.
    #[doc(alias = "polkit_unix_process_set_pid")]
    pub fn set_pid(&self, pid: i32) {
        unsafe {
            ffi::polkit_unix_process_set_pid(self.to_glib_none().0, pid);
        }
    }

    /// Set the start time of `self`.
    /// ## `start_time`
    /// The start time for `pid`.
    #[doc(alias = "polkit_unix_process_set_start_time")]
    pub fn set_start_time(&self, start_time: u64) {
        unsafe {
            ffi::polkit_unix_process_set_start_time(self.to_glib_none().0, start_time);
        }
    }

    /// Sets the (real, not effective) user id for `self`.
    /// ## `uid`
    /// The user id to set for `self` or -1 to unset it.
    #[doc(alias = "polkit_unix_process_set_uid")]
    pub fn set_uid(&self, uid: i32) {
        unsafe {
            ffi::polkit_unix_process_set_uid(self.to_glib_none().0, uid);
        }
    }

    /// Creates a new [`UnixProcess`][crate::UnixProcess] for `pid`.
    ///
    /// The uid and start time of the process will be looked up in using
    /// e.g. the `<filename>`/proc`</filename>` filesystem depending on the
    /// platform in use.
    /// ## `pid`
    /// The process id.
    ///
    /// # Returns
    ///
    /// A [`Subject`][crate::Subject]. Free with `g_object_unref()`.
    #[doc(alias = "polkit_unix_process_new")]
    pub fn new(pid: i32) -> Subject {
        unsafe { from_glib_full(ffi::polkit_unix_process_new(pid)) }
    }

    /// Creates a new [`UnixProcess`][crate::UnixProcess] object for `pid`, `start_time` and `uid`.
    /// ## `pid`
    /// The process id.
    /// ## `start_time`
    /// The start time for `pid` or 0 to look it up in e.g. `<filename>`/proc`</filename>`.
    /// ## `uid`
    /// The (real, not effective) uid of the owner of `pid` or -1 to look it up in e.g. `<filename>`/proc`</filename>`.
    ///
    /// # Returns
    ///
    /// A [`Subject`][crate::Subject]. Free with `g_object_unref()`.
    #[doc(alias = "polkit_unix_process_new_for_owner")]
    pub fn new_for_owner(pid: i32, start_time: u64, uid: i32) -> Subject {
        unsafe { from_glib_full(ffi::polkit_unix_process_new_for_owner(pid, start_time, uid)) }
    }

    /// Creates a new [`UnixProcess`][crate::UnixProcess] object for `pid` and `start_time`.
    ///
    /// The uid of the process will be looked up in using e.g. the
    /// `<filename>`/proc`</filename>` filesystem depending on the platform in
    /// use.
    /// ## `pid`
    /// The process id.
    /// ## `start_time`
    /// The start time for `pid`.
    ///
    /// # Returns
    ///
    /// A [`Subject`][crate::Subject]. Free with `g_object_unref()`.
    #[doc(alias = "polkit_unix_process_new_full")]
    pub fn new_full(pid: i32, start_time: u64) -> Subject {
        unsafe { from_glib_full(ffi::polkit_unix_process_new_full(pid, start_time)) }
    }

    #[doc(alias = "pid")]
    pub fn connect_pid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pid_trampoline<F: Fn(&UnixProcess) + 'static>(
            this: *mut ffi::PolkitUnixProcess,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::pid\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_pid_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "start-time")]
    pub fn connect_start_time_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_start_time_trampoline<F: Fn(&UnixProcess) + 'static>(
            this: *mut ffi::PolkitUnixProcess,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::start-time\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_start_time_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "uid")]
    pub fn connect_uid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_uid_trampoline<F: Fn(&UnixProcess) + 'static>(
            this: *mut ffi::PolkitUnixProcess,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::uid\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_uid_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for UnixProcess {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("UnixProcess")
    }
}
